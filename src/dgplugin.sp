/* Plugin Template generated by Pawn Studio */

#include <sourcemod>
#include <string>
#include <sdktools>
#include <tf2>
#include <sdkhooks>
#include <tf2_stocks>
#include <adt_trie>

#define TEST_MODE 0


#define RED_TEAM 2
#define BLU_TEAM 3


//in tf2_stocks
#define TF2_PLAYERCOND_DISGUISING           (1<<2)
#define TF2_PLAYERCOND_DISGUISED            (1<<3)
#define TF2_PLAYERCOND_SPYCLOAK             (1<<4)


#define DG_SPRITE_RED_VTF   "materials/dg/DG_red.vtf"
#define DG_SPRITE_RED_VMT   "materials/dg/DG_red.vmt"
#define DG_SPRITE_BLU_VTF   "materials/dg/DG_blu.vtf"
#define DG_SPRITE_BLU_VMT   "materials/dg/DG_blu.vmt"
new DrinkListStart[MAXPLAYERS + 1];
new TotalDrinks[MAXPLAYERS + 1];
new BuildingDrinks[MAXPLAYERS + 1];
new DeadRingerDrinks[MAXPLAYERS + 1];
new Handle:Weapons = INVALID_HANDLE;
new Handle:BalanceTimer = INVALID_HANDLE;

enum Eweapon
{
	wepMult,
	String:wepName[40],
};

//Stinky Petes half-birthday!
new String:UpdateDate[] = "10/29/2014";
new Handle:db = INVALID_HANDLE;

new String: msgColor[] = "\x04[DG]";


new g_EntList[MAXPLAYERS + 1];
new g_EntParentList[MAXPLAYERS + 1];
new gVelocityOffset;

new Handle:g_hStatsURL;
new Handle:g_hRulesURL;
new Handle:dgBottleDeath;
new Handle:dgUnfairBalance;
new Handle:dgDebug;

#include "helpers.sp"
#include "effects.sp"

public Plugin:myinfo =
{
	name = "Drinking game plugin",
	author = "Jesse Young (CodeMonkey)",
	description = "Sends players with [DG] in their name a message when they should drink",
	version = "2.1",
	url = "http://www.team-brh.com"
}

public OnPluginStart()
{
	HookEvent("player_death", Event_PlayerDeath);
	HookEvent("teamplay_round_win",Event_Round_Win);
	HookEvent("object_destroyed",SentryDeath);
	HookEvent("player_spawn",Event_PlayerSpawn);
	HookEvent("player_changename",Change_Name);
	HookEvent("teamplay_round_start",Round_Start);
	RegConsoleCmd("say",Command_Say);
	RegConsoleCmd("dg_update",Update);
	RegConsoleCmd("dg_reloadmelee",LoadWepMults);
	RegConsoleCmd("dg_random", RandomDG);
	RegAdminCmd("dg_add_bots", DGAddBots, ADMFLAG_GENERIC);
	RegAdminCmd("dg_balance", DGBalance, ADMFLAG_GENERIC);


	g_hStatsURL = CreateConVar("dg_statsurl", "http://stats.team-brh.com/dg", "Web location where DGers can view their stats");
	g_hRulesURL = CreateConVar("dg_rulesurl", "http://www.team-brh.com/forums/viewtopic.php?f=8&t=7666", "Web location where rules are posted for when a player types dg_info in chat");
	dgBottleDeath = CreateConVar("dg_bottledeath", "1", "Spawn bottles based on how many drinks were given on death");
	dgUnfairBalance = CreateConVar("dg_unfairbalance", "1", "Prevent certain heavy medic pairs from being dg-balanced separated");
	dgDebug = CreateConVar("dg_debug", "0", "Drinking Game Debug Mode");
	//For findtarget
	LoadTranslations("common.phrases");

	LoadSQL();
	LoadWepMults(0,0);

	gVelocityOffset = FindSendPropInfo("CBasePlayer", "m_vecVelocity[0]");
}

public OnPluginEnd() {
	//Kill all sprites on end
	for(new i = 1; i <= MaxClients; i++)
	{
		KillSprite(i);
	}
}

public OnConfigsExecuted() {
	if (GetConVarBool(dgDebug)) {
		return;
	}
	PrecacheSound("vo/burp05.mp3");
}

//is player DG for the purposes of causing drinks
public bool:causesDrinks(String:playerName[]) {
	if(StrContains(playerName,"[DG]",false) != -1) {
		return true;
	}
	if(StrContains(playerName,"[SG]",false) != -1) {
		return true;
	}
	if(StrContains(playerName,"[DCG]",false) != -1) {
		return true;
	}
	if(StrContains(playerName,"[SCG]",false) != -1) {
		return true;
	}
	return false;
}

//is player DG for the purposes of receiving drinks
public bool:mayDrink(String:playerName[]) {
	if(StrContains(playerName,"[DG]",false) != -1) {
		return true;
	}
	if(StrContains(playerName,"[SG]",false) != -1) {
		return true;
	}
	return false;
}

//is player DCG for the purposes of receiving drinks
public bool:willDrink(String:playerName[]) {
	if(StrContains(playerName,"[DCG]",false) != -1) {
		return true;
	}
	if(StrContains(playerName,"[SCG]",false) != -1) {
		return true;
	}
	return false;
}

public OnMapStart() {
	if (GetConVarBool(dgDebug)) {
		return;
	}
	PrecacheGeneric(DG_SPRITE_RED_VMT, true);
	AddFileToDownloadsTable(DG_SPRITE_RED_VMT);
	PrecacheGeneric(DG_SPRITE_RED_VTF, true);
	AddFileToDownloadsTable(DG_SPRITE_RED_VTF);

	PrecacheGeneric(DG_SPRITE_BLU_VMT, true);
	AddFileToDownloadsTable(DG_SPRITE_BLU_VMT);
	PrecacheGeneric(DG_SPRITE_BLU_VTF, true);
	AddFileToDownloadsTable(DG_SPRITE_BLU_VTF);
}

public LoadSQL() {
	if (GetConVarBool(dgDebug)) {
		return;
	}
	new String:error[255]
	db = SQL_Connect("DGGame", true, error, sizeof(error))


	if (db == INVALID_HANDLE) {
		PrintToServer("Could not connect: %s", error);
		return;
	}
	else {
		PrintToServer("DG: Connected to SQL server");
	}
}

public Action:LoadWepMults(client,args) {
	if (GetConVarBool(dgDebug)) {
		return Plugin_Handled;
	}
	if (Weapons != INVALID_HANDLE)
		CloseHandle(Weapons);

	SQL_LockDatabase(db);
	new Handle:query = SQL_Query(db, "SELECT weapon,mult FROM dgwepmults");
	SQL_UnlockDatabase(db);
	Weapons = CreateTrie();


	while (SQL_FetchRow(query))
	{
		new _:weaponinfo[Eweapon];

		SQL_FetchString(query, 0, weaponinfo[wepName], sizeof(weaponinfo[wepName]));
		weaponinfo[wepMult] = SQL_FetchInt(query,1);
		SetTrieValue(Weapons,weaponinfo[wepName],weaponinfo[0]);
	}

	if (client != 0)
		ReplyToCommand(client,"Melee weapons reloaded successfully");

	return Plugin_Handled;
}

public Action:RandomDG(client, args) {
	new String:text[200];
	GetCmdArgString(text,sizeof(text));
	StripQuotes(text);

	new intNum = StringToInt(text);


	new max_clients = GetMaxClients() +1;
	//Loop through all clients
	new i = 0;
	new clients = 0;
	while (i++ < max_clients && clients < intNum) {
		//Make sure client is connected
		if (!IsClientInGame(i)) {
			continue;
		}

		//Get player Name
		new String:playerName[64];
		GetClientName(i, playerName,sizeof(playerName));

		if (causesDrinks(playerName)) {
			continue;
		}

		ServerCommand("sm_rename \"%s\" \"%s[DG]\"", playerName, playerName);
		clients++;
	}
	if (client != 0) {
		ReplyToCommand(client, "DGers added");
	}
	return Plugin_Handled;
}

public Round_Start(Handle:event, const String:name[], bool:dontBroadcast) {
	if (BalanceTimer != INVALID_HANDLE) {
		CloseHandle(BalanceTimer);
		BalanceTimer = INVALID_HANDLE;
	}
	BalanceTimer = CreateTimer(5.0,CallBalance);
}

public Action:CallBalance(Handle:timer) {
	BalanceTimer = INVALID_HANDLE;
	DGBalance(0,0);
}

public Action:Command_Say(client,args) {
	new String:text[200];
	GetCmdArgString(text,sizeof(text));
	StripQuotes(text);
	//Just leave if the console says something
	if (client == 0) {
		return Plugin_Continue;
	}

	//Get the first argument and index of other argument
	new String:cmd[32];
	new nextCmd = BreakString(text,cmd,sizeof(cmd));
	if (cmd[0] == '!') {
		strcopy(cmd[0],sizeof(cmd),cmd[1]);
	}

	new String:steamID[32];
	GetClientAuthId(client,AuthId_Steam2,steamID,sizeof(steamID))

	if (StrEqual(cmd,"dg_drinklist",false)) {
		ReadList(client,0);
	}
	if (StrEqual(cmd,"dg_mytaunt",false)) {
		new String:tag[100];
		GetTaunt(steamID,tag,sizeof(tag),true);
		PrintToChat(client,"%s%s",msgColor,tag);
	}
	if (StrEqual(cmd,"dg_settaunt",false)) {
		if (nextCmd == -1)
			PrintToChat(client,"%sYou must specify a taunt to set",msgColor)
		else {
			new String:taunt[50];
			strcopy(taunt,51,text[nextCmd]);
			if (SetTaunt(steamID,text[nextCmd])) {
				GetTaunt(steamID,taunt,sizeof(taunt),true);
				PrintToChat(client,"%staunt added: '%s'",msgColor,taunt)
			} else
			PrintToChat(client, "%sThere was an error adding this taunt (tell CodeMonkey)",msgColor);
		}
	}

	new String:forumPost[300];
	GetConVarString(g_hRulesURL,forumPost,sizeof(forumPost));

	if (StrEqual(cmd,"dg_info",false)) {
		ShowMOTDPanel(client,"DG Rules",forumPost,MOTDPANEL_TYPE_URL);
	}

	if (StrEqual(cmd,"dg_stats",false)){
		new String: blank[255];
		if (nextCmd == -1)
			DGStats(client, blank);
		else
			DGStats(client, text[nextCmd]);
	}


	if (StrContains(text, "dg",false) != -1 || StrContains(text, "dcg",false) != -1
		|| StrContains(text, "sg",false) != -1 || StrContains(text, "scg",false) != -1) {
		if (StrContains(text, "what is",false) != -1)
			ShowMOTDPanel(client,"DG Rules",forumPost,MOTDPANEL_TYPE_URL);
		else if (StrContains(text, "wat is",false) != -1)
			ShowMOTDPanel(client,"DG Rules",forumPost,MOTDPANEL_TYPE_URL);
		else if (StrContains(text, "wtf is",false) != -1)
			ShowMOTDPanel(client,"DG Rules",forumPost,MOTDPANEL_TYPE_URL);
		else if (StrContains(text, "why do you have",false) != -1)
			ShowMOTDPanel(client,"DG Rules",forumPost,MOTDPANEL_TYPE_URL);
		else if (StrContains(text, "how to",false) != -1)
			ShowMOTDPanel(client,"DG Rules",forumPost,MOTDPANEL_TYPE_URL);
		else if (StrContains(text, "how do",false) != -1)
			ShowMOTDPanel(client,"DG Rules",forumPost,MOTDPANEL_TYPE_URL);
	}

	return Plugin_Continue;
}

public Event_PlayerDeath(Handle:event, const String:name[], bool:dontBroadcast) {
	new bool:buildingDeath = StrEqual(name,"object_destroyed",false);

	//Get user ids of people that the event happend to
	new victim_id = GetEventInt(event, "userid")
	new attacker_id = GetEventInt(event, "attacker")
	new assister_id = GetEventInt(event,"assister")

	//Get their client indexs
	new victim = GetClientOfUserId(victim_id);
	new attacker = GetClientOfUserId(attacker_id);
	new assister = GetClientOfUserId(assister_id);

	if (victim == 0) {
		return;
	}


	new flags = 0;
	if (!buildingDeath) {
		flags = GetEventInt(event,"death_flags")
		//Only kill the sprite if its a player death
		KillSprite(victim);
	}

	//Get weapon that caused death
	new String:WeaponName[128];
	GetEventString(event,"weapon",WeaponName, 128);


	//Get their names
	new String:vicName[50];
	new String:attackName[50];
	new String:assistName[50];

	GetClientName(victim, vicName,sizeof(vicName))
	GetClientName(attacker, attackName,sizeof(attackName))
	GetClientName(assister, assistName,sizeof(assistName))

	//See whos playin DG
	new bool:vicDCG = willDrink(vicName);
	new bool:vicDG  = mayDrink (vicName);
	new bool:atDG   = causesDrinks(attackName);
	new bool:asDG   = causesDrinks(assistName);

	//Exit if vic isnt DGin
	if (!vicDG && !vicDCG)
		return;

	new Handle:myPanel = CreatePanel();
	new String:panelBuffer[100];

	/* --Broken, fix later--
	//Suicide is 2 drinks
	if (victim_id == attacker_id) {
	TotalDrinks[victim] += 2;
	PrintCenterText(victim,"DRINK TWO BITCH");
	PrintToChat(victim,"%sYou're an idiot, drink 2",msgColor);
	EmitSoundToClient(victim,"vo/burp05.mp3");

	//Update to the fact you killed yourself
	Update_DG_DB(victim,0,victim,2,0,2,WeaponName);

	//Display the window
	DrawPanelText(myPanel,"[+2]You committed suicide");
	DrawPanelText(myPanel,"--------------------------------");
	DrawPanelText(myPanel,"Total: 2");
	DrawPanelText(myPanel," ");
	Format(panelBuffer,sizeof(panelBuffer),"Total drinks this round: %d",TotalDrinks[victim]);
	DrawPanelText(myPanel,panelBuffer);
	DrawPanelItem(myPanel,"Close");
	SendPanelToClient(myPanel,victim,MenuHandler1,5);
	CloseHandle(myPanel);
	return;
	}
	*/
	if (GetEventInt(event,"damagebits") & DMG_VEHICLE) {
		TotalDrinks[victim] += 6;
		PrintCenterText(victim,"DRINK SIX BITCH");
		PrintToChat(victim,"%sDon't get disTRACKted, drink 6",msgColor);
		EmitSoundToClient(victim,"vo/burp05.mp3");

	//Update to the train killed you
		Update_DG_DB(victim,0,victim,6,0,6,"train");

	//Display the window
		DrawPanelText(myPanel,"[+6]You got run over by a train");
		DrawPanelText(myPanel,"--------------------------------");
		DrawPanelText(myPanel,"Total: 6");
		DrawPanelText(myPanel," ");
		Format(panelBuffer,sizeof(panelBuffer),"Total drinks this round: %d",TotalDrinks[victim]);
		DrawPanelText(myPanel,panelBuffer);
		DrawPanelItem(myPanel,"Close");
		SendPanelToClient(myPanel,victim,MenuHandler1,5);
		CloseHandle(myPanel);
		return;
	}

	//return if the server killed you
	if(attacker == 0)
		return;

	//If vic is DCGin and attacker isn't tell them to drink
	if (vicDCG && !atDG && !asDG) {
	//Increment drinks
		TotalDrinks[victim] += 1;
		PrintCenterText(victim,"DRINK ONE BITCH");
		PrintToChat(victim,"%sYou're DCGn, drink one",msgColor);

		Update_DG_DB(0,0,victim,0,0,1,"");

		new String:say[255];
		Format(say, sizeof(say),"%s killed you, drink %d", attackName, 1);

	//EmitSoundToClient(victim,"misc/bottle-open-1.mp3");
		EmitSoundToClient(victim,"vo/burp05.mp3");
	//Display the window
		DrawPanelText(myPanel,"[+1]You were killed while DCGing");
		DrawPanelText(myPanel,"--------------------------------");
		DrawPanelText(myPanel,"Total: 1");
		DrawPanelText(myPanel," ");
		Format(panelBuffer,sizeof(panelBuffer),"Total drinks this round: %d",TotalDrinks[victim]);
		DrawPanelText(myPanel,panelBuffer);
		DrawPanelItem(myPanel,"Close");
		SendPanelToClient(myPanel,victim,MenuHandler1,5);
		CloseHandle(myPanel);
	}



	//Exit if attacker and assiter aren't dgin display building deaths if need be
	//or dead ringer deaths
	if (!atDG && !asDG) {
		if (DeadRingerDrinks[victim] > 0) {
			Format(panelBuffer,sizeof(panelBuffer),"[+%d]You would have drank at time of fake death(s)",DeadRingerDrinks[victim]);
			DrawPanelText(myPanel,panelBuffer);
			DrawPanelText(myPanel,"--------------------------------");
			Format(panelBuffer,sizeof(panelBuffer),"Total: %d",DeadRingerDrinks[victim]);
			DrawPanelText(myPanel, panelBuffer);
			DrawPanelText(myPanel," ");
			Format(panelBuffer,sizeof(panelBuffer),"Total drinks this round: %d",TotalDrinks[victim]);
			DrawPanelText(myPanel,panelBuffer);
			DrawPanelItem(myPanel,"Close");
			SendPanelToClient(myPanel,victim,MenuHandler1,5);
			CloseHandle(myPanel);
			DeadRingerDrinks[victim] = 0;
		}
		else if (BuildingDrinks[victim] > 0) {
			PrintCenterText(victim,"DRINK %d BITCH", BuildingDrinks[victim]);
			PrintToChat(victim,"%sYour buildings were killed last life drink %d",msgColor, BuildingDrinks[victim]);
			EmitSoundToClient(victim,"vo/burp05.mp3");
			//Display the window
			Format(panelBuffer,sizeof(panelBuffer),"[+%d]Your buildings were killed that life",BuildingDrinks[victim]);
			DrawPanelText(myPanel,panelBuffer);
			DrawPanelText(myPanel,"--------------------------------");
			Format(panelBuffer,sizeof(panelBuffer),"Total: %d",BuildingDrinks[victim]);
			DrawPanelText(myPanel, panelBuffer);
			DrawPanelText(myPanel," ");
			Format(panelBuffer,sizeof(panelBuffer),"Total drinks this round: %d",TotalDrinks[victim]);
			DrawPanelText(myPanel,panelBuffer);
			DrawPanelItem(myPanel,"Close");
			SendPanelToClient(myPanel,victim,MenuHandler1,5);
			CloseHandle(myPanel);
			BuildingDrinks[victim] = 0;
		}
		return;
	}

	//We don't care about the distinction between the two anymore
	vicDG = (vicDG || vicDCG);

	//Now the taunt for that player
	new String: steamID[32];
	GetClientAuthId(attacker,AuthId_Steam2,steamID,sizeof(steamID));
	new String:attaunt[100];
	GetTaunt(steamID,attaunt,sizeof(attaunt),false);

	new bool:tauntKill = (StrContains(WeaponName,"taunt",false) != -1);

	//Check for domination kill
	new bool:atDomRev = (flags & 1 || flags & 4);
	new bool:asDomRev = (flags & 2 || flags & 8) && asDG;

	if (buildingDeath) {
		TotalDrinks[victim] += 1;
		BuildingDrinks[victim] += 1;
	//should this update for dead ringer coward deaths?
		Update_DG_DB(atDG ? attacker : 0, asDG ? assister : 0, victim, 1, 1, 1, WeaponName);

		PrintToChat(attacker, "%sYou made %s drink %d. Good job!",msgColor, vicName, 1 );
		if (asDG) {
			PrintToChat(assister,"%sYou made %s drink %d. Good job!",msgColor, vicName, 1 );
		}
	}
	else {
		new drinkCount = 0;
		new atDrinkCount = 0;
		new asDrinkCount = 0;
		new String: reason[100] = "";

		if (atDG) {
		//Add one for attacker drinks caused
			atDrinkCount += 1;
			drinkCount += 1;
			StrCat(reason,sizeof(reason), "killed by [DG]");
			Format(panelBuffer,sizeof(panelBuffer),"[+1]You were killed by %s",attackName);
			DrawPanelText(myPanel,panelBuffer);
		}

		//Add one for assiter
		if (asDG) {
		//Add one for assister drinks caused
			asDrinkCount += 1;
			drinkCount += 1;
			if (atDG)
				StrCat(reason,sizeof(reason),", kill assisted by [DG]");
			else
				StrCat(reason,sizeof(reason),"kill assisted by [DG]");

			Format(panelBuffer,sizeof(panelBuffer),"[+1]You were kill-assisted by %s",assistName);
			DrawPanelText(myPanel,panelBuffer);
		}

		//Add one if both gotcha
		if (asDG && atDG) {
		//Add one to both because the both helped with this one
			asDrinkCount+=1;
			atDrinkCount+=1;
			drinkCount  +=1;
			DrawPanelText(myPanel,"[+1] Drinker synergy bonus drink");
		}

		//Add weapon multipliers only if attacker was dg'n
		if (GetEventInt(event,"customkill") != TF_CUSTOM_BACKSTAB && atDG) {
			new multCount = getDrinkCount(WeaponName);
			if (multCount > 0) {
				drinkCount += multCount;
		//Add to attackers drink count
				atDrinkCount+=multCount;
				StrCat(reason,sizeof(reason),", killed using a special weapon");
				Format(panelBuffer,sizeof(panelBuffer),"[+%d]Killed with %s",multCount, WeaponName);
				DrawPanelText(myPanel,panelBuffer);
			}
		}

		//Double for taunt kill if attacker was dg'n
		if (tauntKill && atDG) {
			drinkCount += 6;
			atDrinkCount+=6;
			StrCat(reason,sizeof(reason),", killed by a taunt kill");
			DrawPanelText(myPanel,"[+6]Killed with a taunt kill");
		}

		//Double for attacker domination
		if (atDomRev & atDG) {
			drinkCount += 2;
			atDrinkCount+=2;
			StrCat(reason,sizeof(reason),", [DG] attacker dominated/revenged you");
			Format(panelBuffer,sizeof(panelBuffer),"[+2]You were dominated/revenged by %s",attackName);
			DrawPanelText(myPanel,panelBuffer);
		}

		//Double for assister domination
		//Double for codemonkey's bad spelling as well
		if (asDomRev && asDG) {
			drinkCount += 2;
			asDrinkCount+=2;
			StrCat(reason,sizeof(reason),", [DG] assister dominated/revenged you");
			Format(panelBuffer,sizeof(panelBuffer),"[+2]You were dominated/revenged by %s",assistName);
			DrawPanelText(myPanel,panelBuffer);
		}

		//Display how many drinks that have to take for their building deaths
		if (BuildingDrinks[victim] > 0) {
			drinkCount += BuildingDrinks[victim];
			StrCat(reason,sizeof(reason),", [DG] killed your buildings last life");
			Format(panelBuffer,sizeof(panelBuffer),"[+%d]Your buildings were killed that life",BuildingDrinks[victim]);
			DrawPanelText(myPanel,panelBuffer);
		}

		if (flags & TF_DEATHFLAG_DEADRINGER ) {
			DeadRingerDrinks[victim] += drinkCount;
			Format(panelBuffer,sizeof(panelBuffer),"...but you were dead ringing");
			DrawPanelText(myPanel,panelBuffer);
			//because fake death
			return;
		}

		//Display how many drinks that have to take for their fake deaths
		if (DeadRingerDrinks[victim] > 0) {
			//a victim of his own deception
			drinkCount += DeadRingerDrinks[victim];
			StrCat(reason,sizeof(reason),", you pretended to be killed by [DG]");
			Format(panelBuffer,sizeof(panelBuffer),"[+%d]You would have drank at time of fake death(s)",DeadRingerDrinks[victim]);
			DrawPanelText(myPanel,panelBuffer);
		}

		//Find the last , in the string and replace it with and
		new idx = FindCharInString(reason,',',true);
		if (idx != -1) {
			ReplaceString(reason[idx],sizeof(reason),","," and")
		}

		//Create the death effect based on # of drinks
		CreateDeathEffect(victim, drinkCount);

		//Print out all this info to the victim
		PrintCenterText(victim,"%s DRINK %d BITCH",attaunt, drinkCount);
		PrintToChat(victim,"%sYou were %s drink %d",msgColor, reason, drinkCount);

		PrintToChat(attacker, "%sYou made %s drink %d. Good job!",msgColor, vicName,drinkCount);
		if (asDG) {
			PrintToChat(assister,"%sYou made %s drink %d. Good job!",msgColor, vicName,drinkCount);
		}
		if (GetConVarBool(dgDebug)) {
			EmitSoundToClient(victim,"vo/burp05.mp3");
			Update_DG_DB(atDG ? attacker : 0, asDG ? assister : 0, victim, atDrinkCount, asDrinkCount,drinkCount, WeaponName);
		}
		TotalDrinks[victim] += drinkCount;

		DrawPanelText(myPanel,"--------------------------------");
		Format(panelBuffer,sizeof(panelBuffer),"Total: %d",drinkCount + BuildingDrinks[victim]);
		DrawPanelText(myPanel,panelBuffer);
		DrawPanelText(myPanel," ");
		Format(panelBuffer,sizeof(panelBuffer),"Total drinks this round: %d",TotalDrinks[victim]);
		DrawPanelText(myPanel,panelBuffer);
		DrawPanelItem(myPanel,"Close");
		SendPanelToClient(myPanel,victim,MenuHandler1,5);
		CloseHandle(myPanel);
	}


	if (!buildingDeath) //Means victim died, reset their building destroys
		BuildingDrinks[victim] = 0;

	if (!(flags & TF_DEATHFLAG_DEADRINGER )) //Means victim wasn't faking, reset their faker status
		DeadRingerDrinks[victim] = 0;
}

public getDrinkCount(String:name[]) {
	if (GetConVarBool(dgDebug)) {
		return 3;
	}
	//Make sure not to read a bad map
	if (Weapons != INVALID_HANDLE) {
		new wepBonus = 0;
		GetTrieValue(Weapons,name,wepBonus);
		return wepBonus;
	}
	return 0;
}


public Event_PlayerSpawn(Handle:event, const String:name[], bool:dontBroadcast) {
	if (GetConVarBool(dgDebug)) {
		return;
	}
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new String:playerName[32];
	GetClientName(client, playerName,sizeof(playerName));

	//If they are DG'n put a sprite above their heads
	if (causesDrinks(playerName)) {
		if (GetClientTeam(client) == RED_TEAM) {
			CreateSprite(client,DG_SPRITE_RED_VMT);
		}
		else {
			CreateSprite(client,DG_SPRITE_BLU_VMT);
		}
	}

}

public Action:SetTransmit(entity, client) {
	//ATTN: THIS FUNCTION MAY HOLD THE BUG THAT CAUSES DG SPRITE AT SOME TEAMMATES
	//Do not display if it is the clients own sprite
	if (g_EntList[client] == entity) {
		return Plugin_Handled;
	}

	//Find target entities owner
	new playerLookingAt = 0;
	for(new i = 1; i <= MaxClients; i++)
	{
		if (g_EntList[i] == entity) {
			playerLookingAt = i;
			break;
		}
	}


	//If its a spy disguising or disguised or cloaked don't show it
	if (playerLookingAt > 0) {
		if (GetEntProp(playerLookingAt, Prop_Send, "m_nPlayerCond") & (TF2_PLAYERCOND_DISGUISING|TF2_PLAYERCOND_DISGUISED|TF2_PLAYERCOND_SPYCLOAK))
			return Plugin_Handled;
	}

	//If they are on the same team. Don't show it
	if (playerLookingAt > 0) {
		if (GetClientTeam(client) == GetClientTeam(playerLookingAt)) {
			return Plugin_Handled;
		}
	}

	new String:playerName[32];
	GetClientName(client, playerName,sizeof(playerName));

	//Don't display to non DGers
	if (!causesDrinks(playerName)) {
		return Plugin_Handled;
	}

	return Plugin_Continue;
}

public Change_Name(Handle:event, const String:name[], bool:dontBroadcast)
{
	//Adjust sprites when players change their name
	decl String:newName[32]; GetEventString(event,"newname" , newName, sizeof(newName));
	decl String:oldName[32]; GetEventString(event,"oldname" , oldName,sizeof(oldName));
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new bool:dg    = causesDrinks(newName);
	new bool:wasDG = causesDrinks(oldName);

	//If they are dead don't worry about it it will be taken care of at spawn
	if (!IsPlayerAlive(client)) {
		return;
	}

	//Didn't actually leave or join game just leave
	if (dg && wasDG) {
		return;
	}
	//If they have started DGin
	if (dg && !GetConVarBool(dgDebug)) {
		if (GetClientTeam(client) == RED_TEAM)
			CreateSprite(client,DG_SPRITE_RED_VMT);
		else if (GetClientTeam(client) == BLU_TEAM)
			CreateSprite(client,DG_SPRITE_BLU_VMT);
	} else if(g_EntList[client] > 0) {
		//If it has a sprite kill it
		KillSprite(client);
	}
}

public MenuHandler1(Handle:menu, MenuAction:action, param1, param2) {

}

public SentryDeath(Handle:event, const String:name[], bool:dontBroadcast) {
	Event_PlayerDeath(event,name,dontBroadcast);
}

public Event_Round_Win(Handle:event, const String:name[], bool:dontBroadcast) {
	new team = GetEventInt(event,"team")

	//Get all clients
	new bool:GetYaDikSuk = false;

	//See if there are any drinkers that round
	new bool:drinkers = false;
	for (new i = 1; i <= MaxClients; i++) {
		if (TotalDrinks[i] > 0)
			drinkers = true;
	}

	//Loop through all clients
	for (new i = 1; i <= MaxClients; i++) {
	//Make sure client is connected
		if (!IsClientInGame(i)) {
			continue;
		}

		//Get player Name
		new String:playerName[32];
		GetClientName(i, playerName,sizeof(playerName));


		if (causesDrinks(playerName)){

			//See if HuntersPlaying
			new String:SteamID[32];
			GetClientAuthId(i,AuthId_Steam2,SteamID,sizeof(SteamID));
			//lolwut
			if (StrEqual(SteamID,"STEAM_0:1:6219443",false))
				GetYaDikSuk = true;

			if (!drinkers) {
				PrintToChat(i, "%sNo one even drank that round, get killing you drunks",msgColor);
			}
			//If on losing team
			if (GetClientTeam(i) != team) {
				PrintCenterText(i,"Your team lost! Drink bitch");
			}
		}
		if (DeadRingerDrinks[i] > 0) {
			PrintCenterText(i,"DRINK %d BITCH", DeadRingerDrinks[i]);
			PrintToChat(i,"%sYou were dead ringing you cheeky git %d",msgColor, DeadRingerDrinks[i]);

			new Handle:myPanel = CreatePanel();
			new String:panelBuffer[100];
			if(!GetConVarBool(dgDebug)){
				EmitSoundToClient(i,"vo/burp05.mp3");
			}
			//Display the window
			Format(panelBuffer,sizeof(panelBuffer),"[+%d]You would have drank at time of fake death(s)",DeadRingerDrinks[i]);
			DrawPanelText(myPanel,panelBuffer);
			DrawPanelText(myPanel,"--------------------------------");
			Format(panelBuffer,sizeof(panelBuffer),"Total: %d",DeadRingerDrinks[i]);
			DrawPanelText(myPanel, panelBuffer);
			DrawPanelText(myPanel," ");
			Format(panelBuffer,sizeof(panelBuffer),"Total drinks this round: %d",TotalDrinks[i]);
			DrawPanelText(myPanel,panelBuffer);
			DrawPanelItem(myPanel,"Close");
			SendPanelToClient(myPanel,i,MenuHandler1,5);
			CloseHandle(myPanel);
			DeadRingerDrinks[i] = 0;
		}
		else if (BuildingDrinks[i] > 0) {
			PrintCenterText(i,"DRINK %d BITCH", BuildingDrinks[i]);
			PrintToChat(i,"%sYour buildings were killed last life drink %d",msgColor, BuildingDrinks[i]);

			new Handle:myPanel = CreatePanel();
			new String:panelBuffer[100];
			if(!GetConVarBool(dgDebug)){
				EmitSoundToClient(i,"vo/burp05.mp3");
			}
			//Display the window
			Format(panelBuffer,sizeof(panelBuffer),"[+%d]Your buildings were killed that life",BuildingDrinks[i]);
			DrawPanelText(myPanel,panelBuffer);
			DrawPanelText(myPanel,"--------------------------------");
			Format(panelBuffer,sizeof(panelBuffer),"Total: %d",BuildingDrinks[i]);
			DrawPanelText(myPanel, panelBuffer);
			DrawPanelText(myPanel," ");
			Format(panelBuffer,sizeof(panelBuffer),"Total drinks this round: %d",TotalDrinks[i]);
			DrawPanelText(myPanel,panelBuffer);
			DrawPanelItem(myPanel,"Close");
			SendPanelToClient(myPanel,i,MenuHandler1,5);
			CloseHandle(myPanel);
			BuildingDrinks[i] = 0;
		}
	}

	if (GetYaDikSuk)
		PrintCenterTextAll("GIT YA DIK SUK!");

	new String:TopDrinkers[(MAXPLAYERS + 1)*(66)];
	GetTopDrinkers(TopDrinkers,sizeof(TopDrinkers),5);
	//If there is drinkers that round print out the top 5 DGers
	if (drinkers) {
		PrintToChatAll("%sTop 5 Drinkers:\n%s",msgColor, TopDrinkers);
	}

	for (new start = 1; start <= MaxClients; start++) {
		TotalDrinks[start] = 0;
	}
}

public OnClientDisconnect(client) {
	TotalDrinks[client]=0
	KillSprite(client);
}

new Handle:hUpdateTaunt = INVALID_HANDLE;
new Handle:hInsertTaunt = INVALID_HANDLE;

public bool:SetTaunt(String:steamID[], String:taunt[]) {
	if(GetConVarBool(dgDebug)) {
		return false;
	}
	//Change it to uppercase
	StringToUpper(taunt);

	//Return if the db is closed
	if (db == INVALID_HANDLE) {
		return false;
	}

	SQL_LockDatabase(db);
	if (hUpdateTaunt == INVALID_HANDLE) {
		new String:error[255];
		hUpdateTaunt = SQL_PrepareQuery(db, "UPDATE dgtaunts SET taunt = ? WHERE Steam_ID = ?", error, sizeof(error));
		if (hUpdateTaunt == INVALID_HANDLE){
			tellCodeMonkey(error);
		}
	}
	if (hInsertTaunt == INVALID_HANDLE) {
		new String:error[255];
		hInsertTaunt = SQL_PrepareQuery(db, "INSERT INTO dgtaunts (taunt, Steam_ID) VALUES(?, ?)", error, sizeof(error));
		if (hInsertTaunt == INVALID_HANDLE){
			tellCodeMonkey(error);
		}
	}

	//Create a query for the DB
	new String:strQuery[500];
	Format(strQuery,sizeof(strQuery), "SELECT taunt FROM dgtaunts WHERE Steam_ID = '%s'",steamID);
	new Handle:query = SQL_Query(db,strQuery);

	if (query == INVALID_HANDLE) {
		new String:error[100];
		SQL_GetError(db,error,sizeof(error));
		PrintToServer(error);
		SQL_UnlockDatabase(db);
		return false;
	} else if(SQL_FetchRow(query)) {
		//That means that a row exists, so use update
		SQL_BindParamString(hUpdateTaunt, 0, taunt, false);
		SQL_BindParamString(hUpdateTaunt, 1, steamID, false);
		if (!SQL_Execute(hUpdateTaunt)) {
			new String:error[100];
			SQL_GetError(db,error,sizeof(error));
			tellCodeMonkey(error);
			SQL_UnlockDatabase(db);
			return false;
		}
	} else {
		//Use insert
		SQL_BindParamString(hInsertTaunt, 0, taunt, false);
		SQL_BindParamString(hInsertTaunt, 1, steamID, false);
		if (!SQL_Execute(hInsertTaunt)) {
			new String:error[100];
			SQL_GetError(db, error,sizeof(error));
			tellCodeMonkey(error);
			SQL_UnlockDatabase(db);
			return false;
		}
	}

	SQL_UnlockDatabase(db);
	return true;
}

public Action:Update(client,args) {
	ReplyToCommand(client,"Updated on %s",UpdateDate)
	return Plugin_Handled
}

public Action:ReadList(client, start) {

	new max_clients = GetMaxClients()
	new clients[max_clients]

	for (new s = 0; s < max_clients; s++){
		clients[s] = s+1
	}

	SortCustom1D(clients,max_clients,sortDrinks)

	new String:name[64]
	new String:rtn[max_clients][1000];
	new numDgers = 0;
	for (new i = 1; i <= MaxClients; i++) {
		if (!IsClientInGame(clients[i]))
			continue;

		GetClientName(clients[i],name,sizeof(name))

		//Only count people with drinks
		if (TotalDrinks[clients[i]] > 0) {
			numDgers++;
			new String:strLine[510];

			Format(strLine,sizeof(strLine),"%s drank %d\n",name,TotalDrinks[clients[i]]);

			strcopy(rtn[numDgers - 1][0],1000,strLine);
		}
	}

	if (start < 0) {
		start = 0;
	}
	new stop = start + 5;
	if (stop > numDgers)
		stop = numDgers;

	new Handle:panel = CreatePanel();
	SetPanelTitle(panel, "Drinks this map");
	for (new i = start; i < stop; i++) {
		new String:value[1000]; Format(value, sizeof(value), "%d - %s", i+1, rtn[i]);
		DrawPanelText(panel, value);
	}

	if (start + 5 < numDgers) {
		DrawPanelItem(panel, "Next");
	}
	if (start > 0) {
		DrawPanelItem(panel, "Prev");
	}
	DrawPanelItem(panel, "Close");
	DrinkListStart[client] = start;
	SendPanelToClient(panel,client, DrinkListHandler, 20);
	CloseHandle(panel);
	return Plugin_Handled;
}

public DrinkListHandler(Handle:menu, MenuAction:action, client, value) {

	new numDgers = 0;
	for (new i = 1; i <= MaxClients; i++) {
		if (!IsClientInGame(i)) {
			continue;
		}

		if  (TotalDrinks[i] > 0) {
			numDgers++;
		}
	}
	if (action == MenuAction_Select) {
		new next = 0;
		new prev = 0;
		//Next and prev is on there
		if (DrinkListStart[client] > 0 && DrinkListStart[client] + 5 < numDgers) {
			prev = 2;
			next = 1;
		} else if (DrinkListStart[client] == 0 && DrinkListStart[client] + 5 < numDgers) {
			next = 1;
		} else if (DrinkListStart[client] > 0) {
			prev = 1;
		}

		if (value == prev) {
			ReadList(client, DrinkListStart[client]-5);
		}
		if (value == next) {
			ReadList(client, DrinkListStart[client] + 5);
		}
	}
}

public GetTopDrinkers(String:buffer[], size, listmax) {
	new max_clients = GetMaxClients()
	new clients[max_clients]

	for (new start = 0; start < max_clients; start++){
		clients[start] = start+1
	}

	SortCustom1D(clients,max_clients,sortDrinks)


	new String:name[64]
	//rtn is only going to be as big as the number of players
	new String:rtn[(MAXPLAYERS + 1)*(sizeof(name)+4)]
	new numDgers = 0;
	for (new i = 1; i <= MaxClients; i++) {
		if (numDgers >= listmax) {
			continue;
		}

		if (!IsClientInGame(clients[i])) {
			continue;
		}

		GetClientName(clients[i],name,sizeof(name))

		//Only count people with drinks
		if (TotalDrinks[clients[i]] > 0) {
			numDgers++;
			new String:strLine[510];

			Format(strLine,sizeof(strLine),"%s drank %d\n",name,TotalDrinks[clients[i]]);

			StrCat(rtn,sizeof(rtn),strLine);
		}
	}

	strcopy(buffer,size,rtn);
}


public sortDrinks(elem1, elem2, const array[],Handle:hndl) {
	if (TotalDrinks[elem1] < TotalDrinks[elem2]) {
		return 1;
	}
	if (TotalDrinks[elem1] == TotalDrinks[elem2]) {
		return 0;
	}
	else {
		return -1;
	}
}

public GetTaunt(String:steamID[32], String:buf[], bufLen, bool:returnError) {
	if (StrContains(steamID, "BOT")) {
		return;
	}
	new String:rtn[100] = "";

	//Return if the db is closed
	if (db == INVALID_HANDLE) {
		return;
	}

	//Create a query for the DB
	new String:strQuery[250];
	Format(strQuery,sizeof(strQuery), "SELECT taunt FROM dgtaunts WHERE Steam_ID = '%s'",steamID);
	SQL_LockDatabase(db);
	new Handle:query = SQL_Query(db,strQuery);
	SQL_UnlockDatabase(db);

	if (query == INVALID_HANDLE) {
		SQL_GetError(db,rtn,sizeof(rtn));
		PrintToServer(rtn);
	} else if(SQL_FetchRow(query)) {
		SQL_FetchString(query,0,rtn,sizeof(rtn));
	} else if(returnError) {
		strcopy(buf,bufLen,rtn);
	}
}


public Update_DG_DB(attacker, assister, victim, at_drinks, as_drinks, vic_drinks, String: weapon[]) {
	//Return if the db is closed
	if (db == INVALID_HANDLE || GetConVarBool(dgDebug)) {
		return;
	}

	new String:atName[100] = "NULL";
	new String:atSteam[50] = "NULL";
	new String:asName[100] = "NULL";
	new String:asSteam[50] = "NULL";
	new String:vicName[100] = "NULL";
	new String:vicSteam[50] = "NULL";

	/*
	0 IN attack_name VARCHAR(50),
	1 IN attack_steam_id VARCHAR(50),
	2 IN assist_name VARCHAR(50),
	3 IN assist_steam_id VARCHAR(50),
	4 IN victim_name VARCHAR(50),
	5 IN victim_steam_id VARCHAR(50),
	6 IN weapon VARCHAR(45),
	7 IN attack_drinks INT(11),
	8 IN assist_drinks INT(11),
	9 IN victim_drinks INT(11)
	*/

	if (attacker != 0) {
		GetClientAuthId(attacker,AuthId_Steam2,atSteam,sizeof(atSteam));
		Format(atSteam, sizeof(atSteam),"'%s'",atSteam);
	}
	if (assister != 0) {
		GetClientAuthId(assister,AuthId_Steam2,asSteam,sizeof(asSteam));
		Format(asSteam, sizeof(asSteam),"'%s'",asSteam);
	}

	GetClientAuthId(victim,AuthId_Steam2,vicSteam,sizeof(vicSteam));
	Format(vicSteam, sizeof(vicSteam),"'%s'",vicSteam);

	new String:query[1000];
	SQL_LockDatabase(db);
	SQL_FastQuery(db,"SET NAMES UTF8");
	SQL_UnlockDatabase(db);
	Format(query,sizeof(query),"call add_drinks(%s, %s, %s, %s, %s, %s, '%s', %d, %d, %d);", atName, atSteam, asName, asSteam, vicName, vicSteam, weapon, at_drinks, as_drinks, vic_drinks)

	SQL_TQuery(db, T_SQLThreadReturn, query)
}

public T_SQLThreadReturn(Handle:owner, Handle:hndl, const String:error[], any:data) {
	if (hndl == INVALID_HANDLE)
	{
		tellCodeMonkey(error)
		LogError(error)
	}
}

public StringToUpper(String:str[]) {
	new i = 0;
	while (str[i] != '\0') {
		str[i] = CharToUpper(str[i]);
		i++;
	}
}

public DGStats(client, String:plrname[]) {
	new String:statsUrl[300];
	GetConVarString(g_hStatsURL,statsUrl,sizeof(statsUrl));

	new String:steam[32];
	GetClientAuthId(client,AuthId_Steam2,steam,sizeof(steam));
	if (strlen(plrname) > 0) {
		new String: url[255];
		Format(url,sizeof(url),"%s/dgstats.php?name=%s",statsUrl, plrname);
		ShowMOTDPanel(client,"DG Stats Search",url, MOTDPANEL_TYPE_URL);
	}
	else {
		new String: url[255];
		Format(url,sizeof(url),"%s/dgstats.php?steam_id=%s",statsUrl, steam);
		ShowMOTDPanel(client,"DG Stats player",url, MOTDPANEL_TYPE_URL);
	}
}

public bool:balanced() {
	new RedDGers;
	new BluDGers;

	for (new i = 1; i <= MaxClients; i ++){
		if (IsClientInGame(i)) {
			new String:name[255];
			GetClientName(i, name,sizeof(name));
			if (causesDrinks(name)) {
				if (GetClientTeam(i) == BLU_TEAM) {
					BluDGers++;
				}
				else if (GetClientTeam(i) == RED_TEAM) {
					RedDGers++;
				}
			}
		}
	}

	if (RedDGers == BluDGers || RedDGers == BluDGers +1 || RedDGers == BluDGers -1) {
		return true;
	}
	return false;
}

public Action:DGAddBots(client, args) {
	new count = 20;
	while (count > 0) {
		decl String:command[50];
		if (GetRandomFloat() < 0.8) {
			Format(command, sizeof(command), "tf_bot_add \"[DG] Drinker %i\"", count);
		}
		else {
			Format(command, sizeof(command), "tf_bot_add \"Non Drinker %i\"", count);
		}
		ServerCommand(command);
		count--;
	}
}

public Action:DGBalance(client1, args) {
	//Tally up the DGer's
	new Handle:RedIndex = CreateArray(ByteCountToCells(1));
	new Handle:BluIndex = CreateArray(ByteCountToCells(1));
	new Handle:NonDG = CreateArray(ByteCountToCells(1));

	for (new i = 1; i <= MaxClients; i ++){
		if (IsClientInGame(i)) {
			new String:name[255];
			GetClientName(i, name,sizeof(name));
			if (causesDrinks(name)) {
				if (GetClientTeam(i) == BLU_TEAM)
					PushArrayCell(BluIndex,i);
				else if (GetClientTeam(i) == RED_TEAM)
					PushArrayCell(RedIndex,i);
			}
			else if (!IsClientObserver(i))
				PushArrayCell(NonDG, i);

		}
	}

	if (balanced()) {
		if (client1 != 0) {
			ReplyToCommand(client1, "Players are already balanced");
		}

		return Plugin_Handled;
	}


	new Handle:larger;
	new largerTeam;
	new smallerTeam;
	//Find the larger team to move players from
	if (GetArraySize(RedIndex) > GetArraySize(BluIndex)) {
		larger = RedIndex;
		largerTeam = RED_TEAM;
		smallerTeam = BLU_TEAM;
	}
	else if (GetArraySize(RedIndex) < GetArraySize(BluIndex)) {
		larger = BluIndex;
		largerTeam = BLU_TEAM;
		smallerTeam = RED_TEAM;
	}

	//Perform the balance
	while (GetArraySize(NonDG) > 0 && !balanced()) {
		//Get a random non dger
		new clientindex = 0;
		if (GetArraySize(NonDG) > 0) {
			clientindex = GetRandomInt(0, GetArraySize(NonDG) - 1);
		}
		//Get a random DGer from the larger team
		new dgerindex = GetRandomInt(0, GetArraySize(larger) - 1);

		new client = GetArrayCell(NonDG, clientindex);
		new dger = GetArrayCell(larger, dgerindex);

		if (!IsClientConnected(client) || !IsClientInGame(client)){
			RemoveFromArray(NonDG, clientindex);
			continue;
		}

		//if they are DGin or on the larger team skip them
		if (FindValueInArray(RedIndex,client) != -1 || FindValueInArray(BluIndex,client) != -1 || GetClientTeam(client) == largerTeam){
			RemoveFromArray(NonDG, clientindex);
			continue;
		}

		//Unfair balance
		if (GetConVarBool(dgUnfairBalance)) {
			new String:steam[32];
			GetClientAuthId(dger,AuthId_Steam2,steam,sizeof(steam));
			if (StrContains(steam,"STEAM_0:0:22399196",false) != -1 || StrContains(steam,"STEAM_0:0:20604342",false) != -1) {
				new bool:both = false;
				for (new i = 0; i < GetArraySize(larger); i++) {
					new teamClient = GetArrayCell(larger, i);
					if (teamClient == dger) continue;
					new String:steam2[32];
					GetClientAuthId(teamClient,AuthId_Steam2,steam2,sizeof(steam));
					if (StrContains(steam2,"STEAM_0:0:22399196",false) != -1 || StrContains(steam2,"STEAM_0:0:20604342",false) != -1) {
						both = true;
					}
				}
				//If both steam ids found, continue (don't balance with this dger)
				if (both) continue;
			}
		}

		new String:name[255];
		new String:teamName[4];
		GetClientName(dger,name,sizeof(name));
		ChangeClientTeam(dger,smallerTeam);
		TF2_RespawnPlayer(dger);
		getTeamName(smallerTeam, teamName, sizeof(teamName));
		PrintToChatAll("%sMoved DGer %s to %s team for DG balance",msgColor,name, teamName);

		GetClientName(client, name, sizeof(name));
		ChangeClientTeam(client, largerTeam);
		getTeamName(largerTeam, teamName, sizeof(teamName));
		PrintToChatAll("%sMoved %s to %s team for DG balance",msgColor,name, teamName);
		TF2_RespawnPlayer(client);

		RemoveFromArray(larger, dgerindex);
		RemoveFromArray(NonDG, clientindex);
	}

	return Plugin_Handled;
}


public OnGameFrame()
{
	new ent, Float:vOrigin[3], Float:vVelocity[3];

	for(new i = 1; i <= MaxClients; i++) {
		if (!IsClientInGame(i)) {
			continue;
		}
		if ((ent = g_EntParentList[i]) > 0) {
			if (!IsValidEntity(ent)) {
				g_EntParentList[i] = 0;
			}
			else {
				if ((ent = EntRefToEntIndex(ent)) > 0) {
					GetClientEyePosition(i, vOrigin);
					vOrigin[2] += 25.0;
					GetEntDataVector(i, gVelocityOffset, vVelocity);
					TeleportEntity(ent, vOrigin, NULL_VECTOR,vVelocity);
				}
			}
		}
	}
}

public tellCodeMonkey(const String:tellWhat[]) {
	for (new i = 1; i < MaxClients; i++){
		new String:steam[32];
		if (!IsClientInGame(i) || !IsClientConnected(i)) {
			continue;
		}

		GetClientAuthId(i,AuthId_Steam2,steam,sizeof(steam));
		//tell pete AND codemonkey so pete can examine errors when code not there
		if (StrEqual(steam,"STEAM_0:0:20604342",false) || StrEqual(steam,"STEAM_0:0:61433652]",false)) {
			PrintCenterText(i,"OMG LOOK AT CHAT THERES AN ERROR");
			PrintToChat(i,"%s%s",msgColor,tellWhat);
		}
	}
	LogError(tellWhat);
}
